>Fields declared final are initialized once, but never changed under normal circumstances. The detailed semantics of `final` fields are somewhat different from those of normal fields. In particular, compilers have a great deal of freedom to move reads of `final` fields across synchronization barriers and calls to arbitrary or unknown methods. Correspondingly, compilers are allowed to keep the value of a `final` field cached in a register and not reload it from memory in situations where a non-`final` field would have to be reloaded.

>`final`로 선언된 **필드**는 **한 번 초기화**되지만 일반적인 상황에서는 **변경되지 않습니다.** 
>최종 필드의 세부 의미는 일반 필드의 의미와 다소 다릅니다. 
>특히, 컴파일러는 동기화 장벽을 넘어 최종 필드의 읽기를 이동하고 임의 또는 알 수 없는 메서드에 대한 호출을 자유롭게 이동할 수 있습니다.
>이에 따라 컴파일러는 레지스터에 캐시된 최종 필드의 값을 유지하고 최종이 아닌 필드를 다시 로드해야 하는 상황에서 메모리에서 해당 값을 다시 로드하지 않을 수 있습니다.


>`final` fields also allow programmers to implement thread-safe immutable objects without synchronization. A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads. This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code. `final` fields must be used correctly to provide a guarantee of immutability.

>final 필드를 사용하면 프로그래머는 동기화 없이 스레드로부터 안전한 불변 객체를 구현할 수 있습니다.
>스레드로부터 안전한 불변 객체는 스레드 간에 불변 객체에 대한 참조를 전달하기 위해 **데이터 경합**이 사용되는 경우에도 **모든 스레드에서 불변 객체로 간주**됩니다.
>이는 부정확하거나 악성 코드로 인한 불변 클래스의 오용에 대한 안전 보장을 제공할 수 있습니다.
>**불변성을 보장하려면 final 필드를 올바르게 사용해야 합니다.**


>An object is considered to be _completely initialized_ when its constructor finishes. A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's `final` fields.



>The usage model for `final` fields is a simple one: Set the `final` fields for an object in that object's constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object's constructor is finished. If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object's `final` fields. It will also see versions of any object or array referenced by those `final` fields that are at least as up-to-date as the `final` fields are.